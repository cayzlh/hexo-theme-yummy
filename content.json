{"meta":{"title":"Yummy Demo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"SpringBoot单元测试","slug":"SpringBoot单元测试","date":"2021-03-12T06:02:10.000Z","updated":"2021-04-16T13:03:49.146Z","comments":false,"path":"2021/03/12/SpringBoot单元测试/","link":"","permalink":"http://example.com/2021/03/12/SpringBoot%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","excerpt":"","text":"一、 单元测试的概念概念： 单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。在Java中单元测试的最小单元是类。 单元测试是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确。执行单元测试，就是为了证明这 段代码的行为和我们期望是否一致。 单元测试引用： 众所周知，通过spring initialize创建的Spring Boot项目会在Maven中自动携带很多starter依赖： 其中包含了一个名为spring-boot-starter-test的依赖，本文是围绕这个依赖展开。 Spring Boot中引入单元测试很简单，添加如下依赖（即spring-boot-starter-test依赖）： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; spring-boot-starter-test有如下几个库： spring-boot-starter-testUML图： 二、单元测试的作用在没有接触单元测试之前我们是怎么做测试的？一般有两个方法： 在时间允许的情况下，编写单元测试是程序员对代码的自测，这是对自己代码的负责。 写单元测试的两个动机： 保证或验证实现功能。 保护已经实现的功能不被破坏。 三、Spring Boot引入的MockMvc的概念 什么是Mock? 在面向对象的程序设计中，模拟对象（英语：mock object）是以可控的方式模拟真实对象行为的假对象。在编程过程中，通常通过模拟一些输入数据，来验证程序是否达到预期结果。 为什么使用Mock对象？ 使用模拟对象，可以模拟复杂的、真实的对象行为。如果在单元测试中无法使用真实对象，可采用模拟对象进行替代。 MockMvc的概念 MockMvc是由spring-test包提供，实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，使得测试速度快、不依赖网络环境。同时提供了一套验证的工具，结果的验证十分方便。 接口MockMvcBuilder，提供一个唯一的build方法，用来构造MockMvc。主要有两个实现：StandaloneMockMvcBuilder和DefaultMockMvcBuilder。 MockMVC的基本步骤 (1) mockMvc.perform执行一个请求。(2) MockMvcRequestBuilders.get(“XXX”)构造一个请求。(3) ResultActions.param添加请求传值 (4) ResultActions.accept()设置返回类型 (5) ResultActions.andExpect添加执行完成后的断言。(6) ResultActions.andDo添加一个结果处理器，表示要对结果做点什么事情，比如处使用print()输出整个响应结果信息。(7) ResultActions.andReturn表示执行完成后返回相应的结果。 四、Service层的单元测试第一步： Spring Boot中单元测试类写在src/test/java目录下，你可以手动创建具体测试类，也可以通过IDEA自动创建测试类，如下图：（注：点选并打开相应代码界面，再点击菜单栏的Navigate） 第二步： 按照第一步的方法，点击测试后，出现图一 的对话框（如果想要测试的类已经存在测试类了会被列出来，也可以重新创建一个新的测试类），点击”Create New Test…”会弹出图二 的对话框，可以选择是否生成setUp以及要测试的成员方法等： 图一 图二 第三步： 至此Service层的测试类就创建好了，测试类自动生成到了src/test/java目录下项目的同级目录中 ，如下图： Service层测试代码如下： @SpringBootTest @RunWith(SpringRunner.class) public class XXXServiceTest &#123; @Resource private XXXService XXXService; @Test public void conflictTime() &#123; DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;); LocalDate start = LocalDate.parse(&quot;2020-10-26&quot;, dtf); LocalDate end = LocalDate.parse(&quot;2020-10-31&quot;, dtf); Integer integer = XXXService.ConflictTime(&quot;10000001&quot;, start, end); Assert.assertThat(integer, Matchers.notNullValue());//assertThat断言后面介绍 &#125; &#125; 注解解释： @SpringBootTest：获取启动类，加载配置，寻找主配置启动类（被 @SpringBootApplication 注解的） @RunWith(SpringRunner.class)：让JUnit运行Spring的测试环境,获得Spring环境的上下文的支持 五、Controller层的单元测试创建测试类步骤见第四部分，此处略。 第四部分只是针对Service层做了测试，但是咱么也需要对Controller层（API）做测试，这时候就用到MockMvc了，它使得你无需启动项目工程就能测试这些接口 MockMvc实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，这样可以使得测试速度快、不依赖网络环境，而且提供了一套验证的工具，这样可以使得请求的验证统一而且很方便。 Controller层部分的代码将分为三个代码块讲解，里面有看不懂的代码先不要着急哦😄，会在第五部分结尾处给大家汇总解答的，大家要坚持看到最后哟！😁 代码块一： @SpringBootTest @RunWith(SpringRunner.class) @AutoConfigureMockMvc public class DfTaskRecordControllerTest &#123; @Autowired private MockMvc mockMvc; @Before public void setUp() throws Exception &#123; System.out.println(&quot;---------------start---------------&quot;); save(); get(); System.out.println(&quot;================end================&quot;); &#125; 注解解释： @SpringBootTest&gt;：获取启动类，加载配置，寻找主配置启动类（被 @SpringBootApplication 注解的） @RunWith(SpringRunner.class)&gt;：让JUnit运行Spring的测试环境,获得Spring环境的上下文的支持 @AutoConfigureMockMvc：用于自动配置MockMvc,配置后MockMvc类可以直接注入,相当于new MockMvc @Before:初始化方法 ,对于每一个测试方法都要执行一次 代码块二： @Test @Transactional @Rollback() public void save() throws Exception &#123; String json&quot;&#123;……&#125;&quot;; //执行一个RequestBuilder请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理； mockMvc.perform(MockMvcRequestBuilders .post(&quot;/XXX/save&quot;) .content(json.getBytes()) //传json参数 .accept(MediaType.APPLICATION_JSON) .contentType(MediaType.APPLICATION_JSON_VALUE) .header(&quot;Authorization&quot;,&quot;Bearer ********-****-****-****-************&quot;) ) .andExpect(MockMvcResultMatchers.status().isOk()) .andDo(print()); &#125; 注解解释： @Transactional:开启事务功能 @Rollback(): 事务回滚,默认是true 代码块三： @Test public void get() throws Exception&#123; ResultActions resultActions = mockMvc.perform(MockMvcRequestBuilders .get(&quot;/XXX/get&quot;) .param(&quot;id&quot;, &quot;**********&quot;) .header(&quot;Authorization&quot;, &quot;Bearer ********-****-****-****-************&quot;) ); resultActions.andReturn().getResponse().setCharacterEncoding(&quot;UTF-8&quot;); resultActions.andExpect(MockMvcResultMatchers.status().isOk()).andDo(print()); &#125; &#125; /get运行结果如下： 现在将上面的一些琐碎的知识点汇总一下： 1. mockMvc.perform：执行一个请求 2. MockMvcRequestBuilders.get(“/XXX/get”)：构造一个请求，Post请求使用.post方法 3. contentType(MediaType.APPLICATION_JSON_VALUE)：代表发送端发送的数据格式是application/json;charset=UTF-8 4. accept(MediaType.APPLICATION_JSON)：代表客户端希望接受的数据类型为application/json;charset=UTF-8 5. header(“Authorization”,“Bearer XXXX”)：代表在报文头添加一些必须的信息，这里添加的是token 6. ResultActions.andExpect：添加执行完成后的断言 7. ResultActions.andExpect(MockMvcResultMatchers.status().isOk())：方法看请求的状态响应码是否为200如果不是则抛异常，测试不通过 8. ResultActions.andDo：添加一个结果处理器，表示要对结果做点什么事情，比如此处使用print()：输出整个响应结果信息 六、断言的概念 断言（assert），是编程术语，表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真。可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言而在部署时禁用断言。 使用断言是判断一个函数或对象的一个方法所产生的结果是否符合你期望那个结果。 七、新断言assertThat使用JUnit 4.4 结合 Hamcrest 提供了一个全新的断言语法——assertThat。程序员可以只使用 assertThat 一个断言语句，结合 Hamcrest 提供的匹配符，就可以表达全部的测试思想。 assertThat 的优点： 优点 1： 以前 JUnit 提供了很多的 assertion 语句，如：assertEquals，assertNotSame，assertFalse，assertTrue，assertNotNull，assertNull 等，现在有了 JUnit 4.4，一条 assertThat 即可以替代所有的 assertion 语句，这样可以在所有的单元测试中只使用一个断言方法，使得编写测试用例变得简单，代码风格变得统一，测试代码也更容易维护。 优点 2： assertThat 使用了 Hamcrest 的 Matcher 匹配符，用户可以使用匹配符规定的匹配准则精确的指定一些想设定满足的条件，具有很强的易读性，而且使用起来更加灵活。 优点 3： assertThat 不再像 assertEquals 那样，使用比较难懂的“谓宾主”语法模式（如：assertEquals(3, x);），相反，assertThat 使用了类似于“主谓宾”的易读语法模式（如：assertThat(x,is(3));），使得代码更加直观、易读。 assertThat 的基本语法如下： assertThat( [value], [matcher statement] ); value ：接下来想要测试的变量值；matcher statement ：使用 Hamcrest 匹配符来表达的对前面变量所期望的值的声明，如果 value 值与 matcher statement 所表达的期望值相符，则测试成功，否则测试失败。 八、Postman与Spring Boot 单元测试的区别 Spring Boot的单元测试主要针对方法层面，可以测试Service层这类非对外暴露的接口的类中方法，并且可一次性批量测试多个方法、支持事务回滚。 Postman针对接口进行http测试，我平时这个比较多，创建的测试接口可保存、分类。 九、Postman基本用法Postman是一款功能强大的网页调试与发送网页HTTP请求的工具。Postman能够发送任何类型的HTTP请求(GET, HEAD, POST,PUT..)，附带任何数量的参数和HTTP headers。支持不同的认证机制（basic, digest,OAuth），接收到的响应语法高亮（HTML，JSON或XML）。 安装Postman 官方网站： https://www.getpostman.com/apps 安装后，Postman是介样婶儿滴~~😊","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"转载","slug":"转载","permalink":"http://example.com/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-02-28T20:55:08.000Z","updated":"2021-02-28T20:55:08.000Z","comments":true,"path":"2021/03/01/hello-world/","link":"","permalink":"http://example.com/2021/03/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"API签名验证方案","slug":"API签名验证方案","date":"2020-09-29T08:45:11.000Z","updated":"2021-04-10T06:06:49.791Z","comments":false,"path":"2020/09/29/API签名验证方案/","link":"","permalink":"http://example.com/2020/09/29/API%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%E6%96%B9%E6%A1%88/","excerpt":"","text":"接口安全问题 请求身份是否合法？ 请求参数是否被篡改？ 请求是否唯一？ AccessKey&amp;SecretKey （开放平台）请求身份为开发者分配**AccessKey（开发者标识，确保唯一）和SecretKey**（用于接口加密，确保不易被穷举，生成算法不易被猜测）。 防止篡改参数签名 按照请求参数名的字母升序排列非空请求参数（包含AccessKey），使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串stringA； 在stringA最后拼接上Secretkey得到字符串stringSignTemp； 对stringSignTemp进行MD5运算，并将得到的字符串所有字符转换为大写，得到sign值。 请求携带参数**AccessKey和Sign，只有拥有合法的身份AccessKey和正确的签名Sign才能放行。这样就解决了身份验证和参数篡改问题，即使请求参数被劫持，由于获取不到SecretKey（仅作本地加密使用，不参与网络传输**），无法伪造合法的请求。 重放攻击虽然解决了请求参数被篡改的隐患，但是还存在着重复使用请求参数伪造二次请求的隐患。 timestamp+nonce方案 nonce指唯一的随机字符串，用来标识每个被签名的请求。通过为每个请求提供一个唯一的标识符，服务器能够防止请求被多次使用（记录所有用过的nonce以阻止它们被二次使用）。 然而，对服务器来说永久存储所有接收到的nonce的代价是非常大的。可以使用**timestamp来优化nonce的存储**。 假设允许客户端和服务端最多能存在15分钟的时间差，同时追踪记录在服务端的nonce集合。当有新的请求进入时，首先检查携带的timestamp是否在15分钟内，如超出时间范围，则拒绝，然后查询携带的nonce，如存在已有集合，则拒绝。否则，记录该nonce，并删除集合内时间戳大于15分钟的nonce（可以使用redis的expire，新增nonce的同时设置它的超时失效时间为15分钟）。 实现请求接口：http://api.test.com/test?name=hello&home=world&work=java 客户端 生成当前时间戳timestamp=now和唯一随机字符串nonce=random 按照请求参数名的字母升序排列非空请求参数（包含AccessKey)： stringA=&quot;AccessKey=access&amp;home=world&amp;name=hello&amp;work=java&amp;timestamp=now&amp;nonce=random&quot;; 拼接密钥SecretKey： stringSignTemp=&quot;AccessKey=access&amp;home=world&amp;name=hello&amp;work=java&amp;timestamp=now&amp;nonce=random&amp;SecretKey=secret&quot;; MD5并转换为大写： sign=MD5(stringSignTemp).toUpperCase(); 最终请求： http://api.test.com/test?name=hello&amp;home=world&amp;work=java&amp;timestamp=now&amp;nonce=nonce&amp;sign=sign; 服务端 Token&amp;AppKey（APP）在APP开放API接口的设计中，由于大多数接口涉及到用户的个人信息以及产品的敏感数据，所以要对这些接口进行身份验证，为了安全起见让用户暴露的明文密码次数越少越好，然而客户端与服务器的交互在请求之间是无状态的，也就是说，当涉及到用户状态时，每次请求都要带上身份验证信息。 Token身份验证 用户登录向服务器提供认证信息（如账号和密码），服务器验证成功后**返回Token**给客户端； 客户端将Token保存在本地，后续发起请求时，携带此Token； 服务器检查Token的有效性，有效则放行，无效（Token错误或过期）则拒绝。 安全隐患：Token被劫持，伪造请求和篡改参数。 Token+AppKey签名验证与上面开发平台的验证方式类似，为客户端分配**AppKey（密钥，用于接口加密，不参与传输），将AppKey和所有请求参数组合成源串，根据签名算法生成签名值，发送请求时将签名值一起发送给服务器验证。这样，即使Token被劫持，对方不知道AppKey和签名算法，就无法伪造请求和篡改参数。再结合上述的重发攻击**解决方案，即使请求参数被劫持也无法伪造二次重复请求。 实现登录和退出请求 后续请求 客户端 和上述开放平台的客户端行为类似，把AccessKey改为token即可。 服务端 参考 芋道源码","categories":[{"name":"笔记本","slug":"笔记本","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0%E6%9C%AC/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"接口安全","slug":"接口安全","permalink":"http://example.com/tags/%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8/"}]}],"categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"},{"name":"笔记本","slug":"笔记本","permalink":"http://example.com/categories/%E7%AC%94%E8%AE%B0%E6%9C%AC/"}],"tags":[{"name":"转载","slug":"转载","permalink":"http://example.com/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"接口安全","slug":"接口安全","permalink":"http://example.com/tags/%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8/"}]}